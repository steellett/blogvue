(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Variables"],{"3de4":function(r,t,e){"use strict";e.r(t);var v=function(){var r=this,t=r.$createElement;r._self._c;return r._m(0)},_=[function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("div",[e("h2",[r._v("Переменные, декларативное и императивное программирование")]),e("h3",[r._v("Транскрипт урока")]),e("p",[r._v(" Мы уже знакомы со способом называть что-то, используя константы. Например, это константа pi со значением 3.14. ")]),e("code",[r._v("const pi = 3.14;")]),e("p",[r._v(" После этой строки, каждый раз, когда мы видим pi, мы знаем, что её значение 3.14. Она называется константой, потому что, ээм, она неизменна, постоянна. После этой строки pi всегда будет 3.14, это никогда не изменится. Именно поэтому по аналогии с бумагой я использую ручку. ")]),e("p",[r._v(" Это может показаться ограничением, но вообще — это довольно хорошее свойство. Изменение того, что мы уже создали — сложная задача. Представьте, что пишете код, используя константу, в значении которой не уверены. ")]),e("p",[r._v(" Тем не менее, иногда вам может потребоваться изменить уже существующие данные или, другими словами, их значения. Допустим, вы хотите повторить что-то 5 раз. Один способ — выполнять повторы, отсчитывая до пяти, а затем остановиться. Для этого вам потребуется что-нибудь для хранения счётчика этого меняющегося числа. Константа не будет в таком случае работать — она неизменна, вы не можете изменить её значение после того, как уже создали её. ")]),e("p",[r._v(" Поэтому в JavaScript и многих других языках программирования существует идея переменной. Можно представить ее в виде такой же бумажки, на которой имя написано ручкой, но значение — карандашом. В любой момент можно заменить значение на другое. ")]),e("p",[r._v("Можно посчитать факториал с помощью переменной вот так:")]),e("code",[r._v(" let factorial = 1;"),e("br"),r._v(" factorial = factorial * 2; // 2 "),e("br"),r._v(" factorial = factorial * 3; // 6 "),e("br"),r._v(" factorial = factorial * 4; // 24"),e("br"),r._v(" factorial = factorial * 5; // 120"),e("br")]),e("p",[r._v(" Создать переменную — просто, она выглядит как константа, только вместо const мы пишем let. Мы позволяем ей быть чем-то и это не навсегда. ")]),e("p",[r._v(' Затем мы изменяем значение factorial. Мы бы такого не смогли сделать, если бы factorial был константой. Эта строка означает "изменить значение переменной факториал, на результат умножения факториала на 2". Теперь JavaScript умножает factorial на 2 и хранит этот результат в переменной factorial. Раньше factorial был 1, а теперь это 2. ')]),e("p",[r._v(" Мы повторяем это ещё трижды, каждый раз умножая полученное значение на следующе целое число: на 3, на 4 и на 5. Это то, что вы возможно делаете в уме, когда умножаете числа. Вероятно вы не думали об этом так чётко, но это неплохой способ описания процесса вычисления, если бы вам было нужно объяснить его. ")]),e("p",[r._v(' Идея использования счётчика для повторения чего-то множество раз — распростанённая в программировании, и большинство языков программирования имеют для этого "циклы". Давайте рассмотрим один тип цикла — "цикл while". Это блок кода, который повторяется, пока удовлетворяется какое-то условие. ')]),e("p",[r._v(" Представьте фермера, который работает от рассвета до заката. Другими словами, он работает пока солнце в небе. Вы можете записать: ")]),e("code",[r._v("while (sun is up) { "),e("br"),r._v(" work"),e("br"),r._v(" }"),e("br")]),e("p",[r._v(' Конечно, это не настоящий JavaScript, это просто чтобы показать идею. Эта строка "work" будет повторяться снова и снова, пока солнце над горизонтом. Это значит после каждого повторения нам нужно проверять, действительно ли солнце в небе, и остановиться если это не так. Другими словами: проверить — исполнить, проверить — исполнить, и так далее. ')]),e("p",[r._v("Вот функция факториала с переменными и циклом вместо рекурсии.")]),e("code",[r._v("const factorial = (n) => { "),e("br"),r._v(" let counter = 1;"),e("br"),r._v(" let result = 1;"),e("br"),r._v(" while (counter <= n) {"),e("br"),r._v(" result = result * counter;"),e("br"),r._v(" counter = counter + 1;"),e("br"),r._v(" }"),e("br"),e("br"),r._v(" return result;"),e("br"),r._v(" }"),e("br")]),e("p",[r._v(" О-о, что тут происходит? Во-первых, мы создали две переменные: одна для счётчика, чтобы считать от 1 до верхнего предела, а вторая для текущего результата. ")]),e("p",[r._v(" Затем начинается главная часть: цикл while, который повторяется, пока счётчик меньше или равен n — числу, переданному в эту функцию. Код, который повторяется, простой: мы меняем значения наших двух переменных. Текущий результат умножается на счётчик, а счётчик увеличивается на 1. ")]),e("p",[r._v(' В какой-то момент это условие — "счётчик меньше или равен n" — станет ложным, цикл больше не будет повторяться, а программа перейдёт к следующему этапу — return result. К этому моменту результат станет ответом, потому что за время всех повторов в цикле, результат умножался на 1, затем на 2, 3 и так далее, пока не достиг значения n, каким бы оно ни было. ')]),e("p",[r._v(" Давайте посмотрим, что компьютер делает шаг за шагом, когда мы вызываем факториал 3. ")]),e("ol",[e("li",[r._v("Взять один аргумент — 3, известный внутри, как n")]),e("li",[r._v("Создать переменную counter, установить значение 1")]),e("li",[r._v("Создать переменную result, установить значение 1")]),e("li",[r._v("Проверить: в счётчике — 1, это меньше или равно n, поэтому")]),e("li",[r._v("Умножить result на counter и положить ответ — 1 — в result")]),e("li",[r._v("Добавить 1 к counter и положить ответ — 2 — в counter")]),e("li",[r._v(" Вернуться и проверить: counter — 2, это меньше или равно n, поэтому ")]),e("li",[r._v("Умножить result на counter и положить ответ — 2 — в result")]),e("li",[r._v("Добавить 1 к counter и положить ответ — 3 — в counter")]),e("li",[r._v(" Вернуться и проверить: counter — 3, это меньше или равно n, поэтому ")]),e("li",[r._v("Умножить result на counter и положить ответ — 6 — в result")]),e("li",[r._v("Добавить 1 к counter и положить ответ — 4 — в counter")]),e("li",[r._v(" Вернуться и проверить: counter — 4, это не меньше и не равно n, поэтому остановить повтор и перейти к следующей строке ")]),e("li",[r._v("Вернуть result — 6")])]),e("p",[r._v(' Компьютер выполняет такие операции в миллиарды раз быстрее, но по сути это выглядит именно так. Общее название такого вида сформулированных повторений — "итерация". Наша программа использует итерацию, чтобы рассчитать факториал. ')]),e("p",[r._v(" В прошлый раз мы рассматривали итеративный процесс с рекурсией, а в этот — итеративный процесс без рекурсии. ")]),e("p",[r._v(" Оба используют технику итерации, но с рекурсивными вызовами нам не нужно менять значения, мы просто передаём новые значения в следующий вызов функции. А эта функция факториала не имеет рекурсивных вызовов вообще, поэтому все трансформации должны происходить внутри единственного экземпляра, единственной функциональной коробки. У нас нет выбора, кроме как менять значения содержимого. ")]),e("p",[r._v(' Стиль программирования, который вы видели в предыдущих уроках, называется "декларативным". Сегодняшний стиль, с изменением значений, называется "императивным". ')]),e("p",[r._v("Сравните рекурсивный и нерекурсивный факториалы:")]),e("code",[r._v("const recursiveFactorial = (n) => { "),e("br"),r._v(" if (n === 1) {"),e("br"),r._v(" return 1;"),e("br"),r._v(" }"),e("br"),r._v(" return n * recursiveFactorial(n-1);"),e("br"),r._v(" }"),e("br"),e("br"),r._v(" const factorial = (n) => {"),e("br"),r._v(" let counter = 1;"),e("br"),r._v(" let result = 1;"),e("br"),r._v(" while (counter <= n) {"),e("br"),r._v(" result = result * counter;"),e("br"),r._v(" counter = counter + 1;"),e("br"),r._v(" }"),e("br"),r._v(" return result;"),e("br"),r._v(" }"),e("br")]),e("p",[r._v(" Эта рекурсивная функция — декларативная — она как описание факториала. Она объясняет, что такое факториал. ")]),e("p",[r._v(" Это нерекурсивная итеративная функция, и она императивная — она описывает, что делать, чтобы найти факториал. ")]),e("p",[r._v(' Слово декларативный происходит от латинского "clarare" — разъяснять, заявлять, делать объявление. Вы разъясняете: я хочу, чтобы факториал n был n умножить на факториал n-1. ')]),e("p",[r._v(' Слово императивный происходит от латинского "imperare", что значит "командовать". Вы приказываете чётко передвигаться по шагам — умножать это на это, пока идёт отсчёт и запоминать какие-то числа. ')]),e("p",[r._v("Декларативное — это что. Императивное — это как.")]),e("p",[r._v(" Писать декларативный код, в целом, лучший подход. Ваш код будет легче читать, понимать и делать что-то новое опираясь на него. Некоторые языки провоцируют вас использовать тот или иной подход, а некоторые вообще не оставляют выбора. ")]),e("p",[r._v(" Но в итоге вам нужно будет научиться оценивать, когда императивный подход принесет больше проблем чем решений. ")]),e("p",[r._v(" Следить за изменениями – сложно, и буквально несколько переменных могут сделать систему очень сложной для понимания. ")]),e("p",[r._v(" От изменения состояния* появляется гора багов, а оператор присваивания (assignment statements), который создает изменения, часто является причинами всего зла во вселенной. ")]),e("p",{staticClass:"author-rights"},[r._v(" Материал взят из источника https://ru.hexlet.io/ ")])])}],n={},l=n,c=(e("f891"),e("2877")),i=Object(c["a"])(l,v,_,!1,null,null,null);t["default"]=i.exports},b01a:function(r,t,e){},f891:function(r,t,e){"use strict";var v=e("b01a"),_=e.n(v);_.a}}]);
//# sourceMappingURL=Variables.6dd43324.js.map