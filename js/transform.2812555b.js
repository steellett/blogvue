(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["transform"],{"208c":function(e,t,a){},"62e7":function(e,t,a){"use strict";a.r(t);var r=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},l=[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"transform-page"},[a("h2",[e._v("Трюк: раздельные функции CSS-трансформации")]),a("p",[e._v(" Одно лишь свойство transform в CSS дает нам массу возможностей — можно вращать, сдвигать, масштабировать и не только, и всё это сразу. Но в том, что эти разные функции трансформации входят в одно свойство, таится ловушка. ")]),a("p",[e._v(" Часто бывает нужно применять разные трансформации для разных состояний элемента. Скажем, у нас есть кнопка, которая всегда будет смещена по вертикали на -150%. Когда пользователь наводит на нее мышкой, мы ее чуть уменьшим, а при нажатии (в активном состоянии) перевернем на 180 градусов. В этом примере для кнопки «My Button» приведен CSS-код, который первым приходит на ум по такому описанию, а кнопка «Expected» показывает, как добиться описанного поведения на самом деле. ")]),a("iframe",{staticStyle:{width:"80%"},attrs:{height:"400",scrolling:"no",title:"zYqwPjm",src:"https://codepen.io/steellett/embed/zYqwPjm?height=265&theme-id=dark&default-tab=css,result",frameborder:"no",loading:"lazy",allowtransparency:"true",allowfullscreen:"true"}},[e._v(" See the Pen "),a("a",{attrs:{href:"https://codepen.io/steellett/pen/zYqwPjm"}},[e._v("zYqwPjm")]),e._v(" by steellett ("),a("a",{attrs:{href:"https://codepen.io/steellett"}},[e._v("@steellett")]),e._v(") on "),a("a",{attrs:{href:"https://codepen.io"}},[e._v("CodePen")]),e._v(". ")]),a("p",[e._v(" При наведении мы не просто добавляем масштаб к начальному состоянию кнопки… мы еще и переопределяем исходный сдвиг, так что она масштабируется и возвращается к translateY(0). ")]),a("p",[e._v(" Почему так? Из-за линейной алгебры. То, как происходят эти трансформации, зависит от других трансформаций и их порядка (так что translate(-50%, -50%) scale(.4) rotate(50deg) — не то же самое, что rotate(50deg) translate(-50%, -50%) scale(.4)), в сухом остатке там умножение матриц. Но обычно нам не надо знать настолько глубокие «внутренности» трансформаций. Обычно веб-разработчики просто хотят знать, как управлять этими функциями трансформации по отдельности. ")]),a("iframe",{staticStyle:{width:"80%"},attrs:{height:"400",scrolling:"no",title:"RwaVvGy",src:"https://codepen.io/steellett/embed/RwaVvGy?height=265&theme-id=dark&default-tab=css,result",frameborder:"no",loading:"lazy",allowtransparency:"true",allowfullscreen:"true"}},[e._v(" See the Pen "),a("a",{attrs:{href:"https://codepen.io/steellett/pen/RwaVvGy"}},[e._v("RwaVvGy")]),e._v(" by steellett ("),a("a",{attrs:{href:"https://codepen.io/steellett"}},[e._v("@steellett")]),e._v(") on "),a("a",{attrs:{href:"https://codepen.io"}},[e._v("CodePen")]),e._v(". ")]),a("p",[e._v(" Chrome начал реализовывать отдельные свойства, так что translate, rotate, and scale стали полноправными свойствами, как видно в предыдущем примере (на момент публикации требует Chrome Canary). Но у этого есть свои ограничения: ")]),a("ul",[a("li",[e._v(" Отдельные x-, y‑ и z-компоненты каждого из них по-прежнему привязаны к единому свойству. ")]),a("li",[e._v(" Преобразуются в матрицы они всегда в одном порядке: translate scale rotate. ")]),a("li",[e._v("В ближайшее время — только в Chrome Canary.")])]),a("h2",[e._v("Так что же делать?")]),a("p",[e._v("Использовать CSS-переменные.")]),a("p",[e._v(" Когда я слушал доклад Дэвида Хуршида о CSS-переменых, моим глазам вдруг открылась масса возможностей для применения их в анимации. А когда я начал совать переменные куда только можно, их мощь стала еще яснее. Без дальнейших церемоний… вот трюк, который даст нам больше гибкости (все «как», «что» и «почему» — сразу после примера). ")]),a("iframe",{staticStyle:{width:"80%"},attrs:{height:"400",scrolling:"no",title:"eYZWxgZ",src:"https://codepen.io/steellett/embed/eYZWxgZ?height=265&theme-id=dark&default-tab=css,result",frameborder:"no",loading:"lazy",allowtransparency:"true",allowfullscreen:"true"}},[e._v(" See the Pen "),a("a",{attrs:{href:"https://codepen.io/steellett/pen/eYZWxgZ"}},[e._v("eYZWxgZ")]),e._v(" by steellett ("),a("a",{attrs:{href:"https://codepen.io/steellett"}},[e._v("@steellett")]),e._v(") on "),a("a",{attrs:{href:"https://codepen.io"}},[e._v("CodePen")]),e._v(". ")]),a("p",[e._v(" Мы задаем ключевой начальный transform нашему элементу с помощью всех переменных, которые мы собираемся менять. Модифицируя значение переменной для другого состояния, мы можем получить CSS-правило, более похожее на наш первоначальный код, но с гораздо большей гибкостью при усложнении. В этом примере мы обрабатываем намного больше наших первоначальных трех состояний, подключив к делу JavaScript (но это не обязательно: вот версия нашего первого примера с кнопкой на одном CSS). Фактически, тут по-прежнему определено одно CSS-свойство, и мы меняем только одну функцию трансформации за раз (без разницы, в JS или в CSS). ")]),a("p",[e._v(" Без CSS-переменных мы бы не обошлись без расчетов (причем далеко не всегда тривиальных) для текущего перехода при изменении каждой функции трансформации. Тогда мы могли бы узнать текущее значение каждой из двух других функций, чтобы убедиться, что переход останется плавным. ")]),a("h2",[e._v("Чем это лучше будущих отдельных свойств из Chrome Canary?")]),a("ul",[a("li",[e._v(" Можно как угодно комбинировать x, y и z, поскольку мы сами решаем, как задать transform изначально. ")]),a("li",[e._v(" Аналогично, мы можем задавать какой нам угодно порядок функций трансформации (хотя и теряем не столь часто нужную, наверное, возможность менять этот порядок от одного состояния к другому). ")]),a("li",[e._v(" Я проверил, что это хорошо работает в новейшем Chrome (56), Firefox (50) и Safari (только в Technical Preview — Safari 10 поддерживает переменные, но без плавных переходов). Я пока не смог проверить в Edge Insider Preview (первой версии, которая поддерживает CSS-переменные) — так что, пожалуйста, сообщите, если у вас будут новости с того фронта. ")])])])}],s={name:"transform",data:function(){return{}}},n=s,o=(a("f669"),a("2877")),i=Object(o["a"])(n,r,l,!1,null,"556e6904",null);t["default"]=i.exports},f669:function(e,t,a){"use strict";var r=a("208c"),l=a.n(r);l.a}}]);
//# sourceMappingURL=transform.2812555b.js.map